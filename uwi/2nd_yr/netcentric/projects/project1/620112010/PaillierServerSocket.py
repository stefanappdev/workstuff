# Server to implement simplified 'secure' electronic voting algorithm
# and tally votes from a client.

# Author: Stefan Mitchell
# Last modified: 2020-10-07
# Version: 0.1.1
#!/usr/bin/python3

import math
import random
import socket
import sys
import threading
FORMAT='utf-8'

class NumTheory:
        @staticmethod
        def expMod(b,n,m):
            """Computes the modular exponent of a number"""
            """returns (b^n mod m)"""
            if n==0:
                return 1
            elif n%2==0:
                return NumTheory.expMod((b*b)%m, n/2, m)
            else:
                return(b*NumTheory.expMod(b,n-1,m))%m
        
        @staticmethod
        def gcd_iter(u, v):
            """Iterative Euclidean algorithm to find the greatest common divisor of
            integers u and v"""
            while v:
                u, v = v, u % v
            return abs(u)
        
        @staticmethod
        def lcm(u, v):
            """Returns the lowest common multiple of two integers, u and v"""

            return int((u*v)/NumTheory.gcd_iter(u, v))
        
        @staticmethod
        def ext_Euclid(m,n):
            """Extended Euclidean algorithm. It returns the multiplicative
                inverse of n mod m"""
            a = (1,0,m)
            b = (0,1,n)
            while True:
                if b[2] == 0: return a[2]
                if b[2] == 1: return int(b[1] + (m if b[1] < 0 else 0))
                q = math.floor(a[2]/float(b[2]))
                t = (a[0] - (q * b[0]), a[1] - (q*b[1]), a[2] - (q*b[2]))
                a = b
                b = t
        
        @staticmethod
        def L(x, n):
            """Function needed for unscrambling data """
            return math.floor((x-1)/n)






class PaillierServerSocket:

       
       
       def __init__(self, host, port):

            #intializing class attributes of server

            self.host=host #sets host value to entered ip address
            self.port=port #sets port number
            self.sock=None
            self.client_sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)#socket for commounicatie with client

            self.start_server(host,port)


       def connect(self, host, port):
            # code to connect to a host and port

 
             try:    
                self.sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                print("socket creation sucessful\n")
                
                try:
                    self.sock.bind((host,port))#binds host and port number to server
                    print("socket binding sucessful\n")

                except socket.error:
                        print("socket binding was unsucessful\n")
                        exit(-1)
            
             except socket.error:
                        print("socket creation failed")
                        exit(-1)
                       
                       
    #function for handling connection with clients
       def handle_client(self,client,addr):
            
           
            connected=True
           
            print("connection Established with"+str(addr))
            
            while connected:
                 
                                
                #formats message from client
                full_msg=""
                client_reply=self.client.recv(200)#reply message from client

                full_msg+=client_reply.decode(FORMAT)

                print("From client "+str(addr)+": "+full_msg)
                greeting="Hello, You are connected to the server\n"
                self.mysend(greeting)          

                if full_msg=="100 Hello":
                        print("please wait for a moment processing....")
                        self.ProcessMsgs()

                #disconnects client from server

                elif full_msg=="terminate":
                        break

                
                 
                

            print("disconnected from client\n")     
            client.close()


       def ProcessMsgs(self):
	     #Main event processing method

       
            candidate_1=input("Please the enter the first name of first candidate\n")
            candidate_2=input("Please the enter the first name of second candidate\n")

          
            n=int(input("PLease enter first part of public key generated by server:"))
            g=int(input("PLease enter second part of public key generated by server:"))

            Id_list=[]
            first_msg="105 key "+str(n)+","+str(g)#first message to client
            self.mysend(first_msg)
            print(first_msg)

            for k in range(1,3):
                ID=2**(k)
                print("ID:",ID)
                Id_list.append(ID)

            second_msg="106 "+"{ID:"+str(Id_list[0])+":"+candidate_1+"},"+"{ID:"+str(Id_list[1])+":"+candidate_2+"}"+"\n"#first message to client
            print(second_msg)
            self.mysend(second_msg)#second message

            third_msg="107 Polls Open"
            self.mysend(third_msg)#third message

            vote=self.client.recv(200)#reply message from client
            vote_msg=vote.decode(FORMAT)


            self.mysend("220 the winner is....")
            self.mysend("terminate")
            print("server has been shutdown\n")
            self.sock.close()


       def start_server(self,host,port):

             
             self.connect(host,port)

             print("Server is loading...\n")
             print("Server of Stefan Mitchell\n")
             print("Listening for incoming connections....\n")
             self.sock.listen(3)#listens for incoming connections
                        
             while True:
                    self.client,addr=self.sock.accept()#accepts incoming connections
                    
                    thread = threading.Thread(target=self.handle_client, args=(self.client,addr))#puts clients on a thread
                    thread.start()
                    print("connections active:"+str(threading.activeCount()-1))
                    
                
             
            


       def mysend(self,msg):
            """Add code here to send message into the socket"""
            data=str(msg)
            self.client.send(data.encode(FORMAT))
            print("Sending message to Client....\n")
            




        
       #receive function was not used
       def myreceive(self,msg):
            """Add code here to read data from the socket"""
            full_msg=""
            while True:
                if len(msg)<=0:
                    break
                full_msg+=msg.decode(FORMAT)

                return(full_msg)



















            
'''
This will be run if you run this script from the command line. You should not
change any of this; the grader may rely on the behavior here to test your
submission.
'''
if __name__ == "__main__":
    args = sys.argv
    if len(args) != 2:
        print ("Please supply a server port.")
        sys.exit()
    HOST = ''                # Symbolic name meaning all available interfaces
    PORT = int(args[1])     # The port on which the server is listening
    if PORT < 1023 or PORT > 65535:
        print("Invalid port specified.")
        sys.exit()
        
    p = int(input('Enter P : '))
    q = int(input('Enter Q: '))
    n = p*q
    euler = (p-1)*(q-1)
    lAmbda = NumTheory.lcm(p-1, q-1)
    if NumTheory.gcd_iter(n, euler) != 1:
        print(str(n) + " is not relatively prime to " + str(euler))
        sys.exit()
    gen = random.randint(1,n**2)
    L_fn_input = NumTheory.expMod(gen, lAmbda, n**2)
    mu = NumTheory.ext_Euclid(n,NumTheory.L(L_fn_input,n))
    print("Public key: (" + str(n) + "," + str(gen) +")")
    print("Private key: " + str(lAmbda))
    print("mu: " + str(mu))
    
    print("Server of _____")
    s = PaillierServerSocket(HOST,PORT)
